# ⚔️ DSA PRECISION ROADMAP (Your Version)

**Python • Precision Mode • ML-oriented placements**

---

# PHASE 1 — CORE PATTERNS (Foundations)

These are non-negotiable. Every big company tests these.

## 1️⃣ Hashmaps

- Two Sum
- Frequency counting
- Complement lookups
- Missing / repeating elements

## 2️⃣ Sliding Window

- Fixed window
- Variable window
- Longest substring problems
- Max/min subarray within constraints

## 3️⃣ Binary Search (Three Forms)

a. Normal BS → sorted arrays  
b. Boundary BS → first ≥ target, last ≤ target  
c. BS on answer → feasibility, minimizing/maximizing something

### ✔ Already done:

- Two Sum
- Longest substring
- BS on answer and boundaries basics

### Next in BS:

- Rotated sorted array search
- Peak element
- First bad version pattern

---

# PHASE 2 — ARRAY POWER TOOLS

## 4️⃣ Prefix Sum

- Subarray sum = K
- Longest subarray sum K
- Zero-sum subarrays

## 5️⃣ Kadane (Max Subarray)

- Classic max sum
- Start/end indices
- Variations

## 6️⃣ Intervals (Greedy)

- Merge intervals
- Activity selection
- Minimum intervals to remove
- Insert interval

### ✔ Already started:

- Merge
- Non-overlap count

---

# PHASE 3 — GRAPH ESSENTIALS

(_You ONLY need these for ML Engineer / SWE-y roles._  
**No heavy DP on graphs, no Dijkstra, no MST needed.**)

## 7️⃣ BFS

- Shortest path in unweighted graphs
- BFS on grids (islands, flood fill)

## 8️⃣ DFS

- Connected components
- Grid exploration
- Cycle detection (basic)

## 9️⃣ Topological Sort (once)

- DAG scheduling
- Prerequisite problems

---

# PHASE 4 — MEDIUM-LEVEL PROBLEMS (Focused Practice)

Solve **5–7 problems per pattern**, not 50 random LeetCode questions.

Included topics:

- Two pointers (3Sum, container with most water)
- Monotonic stack basics (next greater element)
- Heaps for greedy scheduling
- Basic DP-lite (fibonacci, house robber)
- Strings (pattern matching, anagrams)

**No garbage DP. No segment trees. No overkill.**

---

# PHASE 5 — INTERVIEW EXECUTION

- Explain thought process clearly
- Identify the pattern instantly
- Solve medium-level problem in 20–25 minutes
- Cover edge cases
- Articulate time & space complexity

---
